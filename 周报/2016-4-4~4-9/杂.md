  最近准备在项目实践一下单页应用，看了几个目前流行的框架，准备上手前看到了一篇大神的帖子，颇有感触，遂摘抄整理以备后用。
##为什么要学习单页应用

- 解决现有问题：现在的项目基本属于裸写前端，整个项目比较杂乱，没有形成工程化。
- 为了解决将来可能遇到的问题：将来随着项目规模越来越大，如果没有一个良好的基础，开发效率很很低。
## 备选对象
  Angular、React、Vue<br>
  这三者中，Angular的适用领域相对窄一些，React可以拓展到服务端和移动端Native部分，而Vue因为比较轻量，还能用于业务场景非常轻的页面中。<br>
### 在Web应用中，我们需要解决的问题可以归纳为三类：  
- 状态
- 组织
- 效率

#### 什么是状态？
  在一个业务界面中，我们可能会根据某些数据去生成一块界面，然后通过界面上某些操作，改变一些数据，从而影响界面的另外一些部分。<br>
  这里面就存在着两种关系，一种是从数据到界面，一种是从界面到数据。能够描述界面当前状况的数据，就可以被称为状态。<br>
  如果不对状态作抽象，很有可能会导致逻辑的混乱，比如说，一个地方点了，要改多个地方，这种代码直接写的话，很容易修改，后期维护也很困难，所以，不同的框架都会采用不同的方式对状态进行处理。<br>
  MVVM的Angular、Vue、Avalon、Regular、Knockout等是通过模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则，从数据更新界面状态。<br>
  React走的是另外一条路，就是所谓的函数式，在这个里面，推崇的是单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。
#### 什么是组织？
  所谓组织，指的是两个方面，一个是模块关系，另一方面是业务模型。
  我们是怎么解决模块关系的呢？共识就是组件化，整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。这些东西说起来简单，但实际做的时候还是有非常多需要考虑的东西，包括组件的定义、约束、管理和测试，而在Web这个体系中，组件化有一些不太适合的场景，需要做一些权衡。<br>
  当我们提到React的时候，就会听到Flux、Redux之类的东西，为什么要用它们呢？我们必须认识到，脱离了这类东西，纯上层的组件化是不牢靠的，如果你感受不到，只有一个原因：你项目的业务层太薄。<br>
  业务模型指的是所处领域中的业务数据、规划、流程的集合。即使抛开所有的展示层，这一层也是应当要能够运作起来的。<br>
  那么，这跟Redux之类有什么关系呢？<br>
  我们刚才提到组件化，整个应用形成了一个组件树，组件之间会需要通信，它们通信的内容可能是简单的界面事件，也可能是业务含义较深，牵一发而动全身的。界面是怎么来的？是由初始界面加上状态形成的，为了能够反映界面的变化，我们必须使得对业务模型的每一个扰动都收敛到确切的状态，所以，这也是就是Redux这类东西存在的意义。<br>
  所以，没有Redux之类辅助方案的React是不完整的。而Redux本身，也不是局限到只能作为React的辅助方案，它的理念，对于Angular、Vue同样是非常重要的补充。在同一业务场景下，对于每个框架来说，数据模型层面面临的问题都是一样的，在这一层并没有任何分别。<br>
  在这里补充一句自己的想法，很多学习能力强的朋友，当他们发现FP（函数式编程）、FRP（函数式反应型编程）之类编程模型的时候，会非常喜欢，但对于大型项目、需要很多人协同的时候，这类模型不一定是好事。<br>
  用面向过程、面向对象的这些编程方式，虽然笨重，但是门槛较低，符合大多数人的理解和思维方式，并且可以复用几十年积累的各种设计模式和经验。所以，如果不是小而精的团队，不要盲目引进FP和FRP这类编程模型。<br>
  很多人吐槽Angular大而全显得笨重，吐槽React全家桶，但其实世界上大部分人是没有框架整合能力的，小而美的库最后整合了，但在面临各种业务需求之后不断引入新模块，也还是一个大而全的方案。在绝大部分场景下，还是有一整套标配模块比较好。ExtJS页单独提供了ExtCore模块，但它不但竞争不过jQuery，连mootools和prototype都竞争不过，几乎也没人单独用。
#### 效率
  效率分两种，一种是开发效率，一种是运行效率。<br>
  我们前面提到，组件化，这是提升开发效率的一种手段。在组件化这个点上，各种框架的组织方式大同小异，反正最终都是组件树。<br>
  MVVM系的代码量会少一点，开发效率稍高一点。其中，Angular因为实现的特殊性，有作用域继承之类的双刃剑，开发效率的不稳定因素高，深刻理解的人用起来效率很高，不理解的用了到处是坑。<br>
